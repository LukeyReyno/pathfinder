{"version":3,"sources":["Pathfinding/Tile/Tile.jsx","Pathfinding/Pathfinding.jsx","Algorithms/BFS.js","Algorithms/DFS.js","Algorithms/dijkstra.js","App.js","reportWebVitals.js","index.js"],"names":["Tile","props","state","this","row","col","isFinish","isStart","isObstacle","onMouseDown","onMouseUp","onMouseEnter","extraClassName","id","className","Component","INITIAL_START_POS","INITIAL_FINISH_POS","visit_time","DIRECTIONS","ALGORITHMS","grid","startTile","finishTile","directions","distance","queue","visitedTilesInOrder","possiblePath","queueLoop","length","current","shift","d","isVisited","push","newCoordinateX","newCoordinateY","neighbor","Infinity","results","shortestPath","pathFromStartToFinish","minNeighbor","unshift","collectPath","console","log","stack","stackLoop","pop","tile","otherTile","vertexSet","Set","prev","i","j","add","size","vArray","Array","from","sort","a","b","delete","has","alt","Math","sqrt","pow","u","undefined","Pathfinding","initializeGrid","currentRow","currentTile","startPosition","finishPosition","mouseIsPressed","directionsIndex","algorithmIndex","timeoutIDs","isSimulating","dragStart","dragFinish","adviceObject","newGrid","setState","setUpChoice","getAdvice","axios","get","then","response","data","status","advice","error","document","getElementById","value","textContent","dropDownElement","addEventListener","choice","target","vistedTilesInOrder","tID","setTimeout","tIDList","style","backgroundColor","clearTimeout","paths","animateTraversal","animateShortestPath","onClick","visualize","resetVisualization","resetGrid","htmlFor","name","class","type","min","max","defaultValue","step","onInput","handleTimeScaleChange","source","width","COL_LENGTH","map","rowIndex","height","tileIndex","handleMouseDown","handleMouseUp","handleMouseEnter","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.24385e5c.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './Tile.css'\n\nexport default class Tile extends Component {\n   constructor(props) {\n      super(props);\n      this.state = {};\n   }\n\n   render() {\n      // Determine if properties are true, in order to add it to class name\n      const {\n         row, \n         col, \n         isFinish, \n         isStart,\n         isObstacle,\n         onMouseDown,\n         onMouseUp,\n         onMouseEnter,\n      } = this.props;\n      const extraClassName = isFinish\n         ? 'finish-tile'\n         : isStart\n         ? 'start-tile'\n         : isObstacle\n         ? 'obstacle-tile'\n         : '';\n\n      return (\n      <div \n      id={`tile-${row}-${col}`}\n      className={`tile ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseUp={() => onMouseUp()}\n      onMouseEnter={() => onMouseEnter(row, col)}>\n      </div>\n      )\n   }\n}\n","import React, {Component} from \"react\";\nimport axios from 'axios';\nimport Tile from './Tile/Tile'\nimport {breadthFirstSearch} from '../Algorithms/BFS'\nimport {depthFirstSearch} from '../Algorithms/DFS'\nimport {dijkstra} from '../Algorithms/dijkstra'\n\nimport './Pathfinding.css';\n\nconst TILE_WIDTH = 25; // in pixels\nconst ROW_LENGTH = 15;\nconst COL_LENGTH = 50;\n\nconst INITIAL_START_POS = [10, 5];\nconst INITIAL_FINISH_POS = [6, 45];\n\n// Typically the same as the tile\nconst ROW_HEIGHT = \"25px\";\n\nvar visit_time = 25; // in ms\n\n// Neighboring nodes -- TilePosition + (a, b)\nconst CARDINAL = [[1, 0], [0, 1], [-1, 0], [0, -1]];\nconst DIAGONAL = [[1, 1], [-1, 1], [-1, -1], [1, -1]];\nconst CARDINAL_DIAGONAL = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\nconst KNIGHT_TRAVERSE = [[2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, -2], [2, -1]];\nconst DIRECTIONS = [CARDINAL, DIAGONAL, CARDINAL_DIAGONAL, KNIGHT_TRAVERSE];\n\nconst ALGORITHMS = [breadthFirstSearch, depthFirstSearch, dijkstra];\n\n// General Pathfinding Main Object\nexport default class Pathfinding extends Component {\n   constructor(props) {\n      super(props);\n      this.state = {\n         grid: [],\n         mouseIsPressed: false,\n         directionsIndex: 0,\n         algorithmIndex: 0,\n         timeoutIDs: [],\n         isSimulating: false,\n         startPosition: INITIAL_START_POS,\n         finishPosition: INITIAL_FINISH_POS,\n         dragStart: false,\n         dragFinish: false,\n         adviceObject: {} \n      };\n   }\n\n   // Create a matrix of row length and col length\n   initializeGrid = () => {\n      const grid = [];\n      for (let row = 0; row < ROW_LENGTH; row++) {\n         const currentRow = [];\n         for (let col = 0; col < COL_LENGTH; col++) {\n            const currentTile = {\n               row,\n               col,\n               distance: Infinity,\n               isVisited: false,\n               isStart: row === this.state.startPosition[0] && col === this.state.startPosition[1],\n               isFinish: row === this.state.finishPosition[0] && col === this.state.finishPosition[1],\n            };\n            currentRow.push(currentTile);\n         }\n         grid.push(currentRow);\n      }\n      return grid;\n   }\n\n   resetGrid() {\n   // wipes the obstacles on the grid, if not simulating\n      if (this.state.isSimulating) return;\n      const newGrid = this.initializeGrid();\n      this.setState({grid: newGrid});\n   }\n\n   componentDidMount() {\n      const grid = this.initializeGrid();\n      this.setState({grid});\n      this.setUpChoice();\n      this.getAdvice();\n   }\n\n   getAdvice() {\n        try {\n            axios.get('https://gitfit.lucasreyna.me/advice').then(response => {\n                // response data is an array with 1 object\n                const adviceObject = response.data[0];\n                console.log(response.status); \n                console.log(adviceObject.advice);\n                this.setState({adviceObject}); //should be json object with adivce and source\n            });\n        }\n        catch (error){\n            //We're not handling errors. Just logging into the console.\n            console.log(error);\n            return false;\n        }\n    }\n\n   // Following mouse functions handles dragging of obstacle tiles\n   handleMouseDown(row, col) {\n      if (this.state.isSimulating) return;\n      const newGrid = this.state.grid;\n      if (newGrid[row][col].isStart) {\n         this.setState({dragStart: true, mouseIsPressed: true});\n         console.log(\"down on start\");\n      } \n      else if (newGrid[row][col].isFinish) {\n         this.setState({dragFinish: true, mouseIsPressed: true});\n      }\n      else {\n         newGrid[row][col].isObstacle = !newGrid[row][col].isObstacle;\n         this.setState({grid: newGrid, mouseIsPressed: true});\n      }\n   }\n\n   handleMouseEnter(row, col) {\n      if (!this.state.mouseIsPressed || this.state.isSimulating) return;\n      const newGrid = this.state.grid;\n      if (this.state.dragStart) {\n         newGrid[this.state.startPosition[0]][this.state.startPosition[1]].isStart = false;\n         newGrid[this.state.startPosition[0]][this.state.startPosition[1]].distance = Infinity;\n         document.getElementById(`tile-${this.state.startPosition[0]}-${this.state.startPosition[1]}`).className = 'tile ';\n         this.setState({startPosition: [row, col]});\n         newGrid[row][col].isStart = true;\n         document.getElementById(`tile-${row}-${col}`).className = 'tile start-tile';\n      } \n      else if (this.state.dragFinish) {\n         newGrid[this.state.finishPosition[0]][this.state.finishPosition[1]].isFinish = false;\n         document.getElementById(`tile-${this.state.finishPosition[0]}-${this.state.finishPosition[1]}`).className = 'tile ';\n         this.setState({finishPosition: [row, col]});\n         newGrid[row][col].isFinish = true;\n         document.getElementById(`tile-${row}-${col}`).className = 'tile finish-tile';\n      }\n      else\n      {\n         newGrid[row][col].isObstacle = !newGrid[row][col].isObstacle;\n      }\n      this.setState({grid: newGrid, mouseIsPressed: true});\n   }\n   \n   handleMouseUp() {\n      this.setState({mouseIsPressed: false, dragStart: false, dragFinish: false});\n   }\n\n   handleTimeScaleChange() {\n   // change time scale value with the scroll and text\n      visit_time = document.getElementById('time slider').value;\n      document.getElementById('time value').textContent = visit_time;\n   }\n\n   // drop down menu selector\n   setUpChoice() {\n      let dropDownElement = document.getElementById(\"directionSelection\");\n      dropDownElement.addEventListener(\"change\", (choice) => {\n         const value = choice.target.value;\n         if (value) {\n            this.setState({directionsIndex: value});\n         }\n      })\n\n      dropDownElement = document.getElementById(\"algorithmSelection\");\n      dropDownElement.addEventListener(\"change\", (choice) => {\n         const value = choice.target.value;\n         if (value) {\n            this.setState({algorithmIndex: value});\n         }\n      })\n   }\n\n   // handles changes in tile color \n   animateTraversal(vistedTilesInOrder) {\n      for (let i = 0; i < vistedTilesInOrder.length; i++) {\n         // In case specific algorithms return start or finish in their visitation order\n         if (vistedTilesInOrder[i] === this.state.grid[this.state.finishPosition[0]][this.state.finishPosition[1]]) continue;\n         if (vistedTilesInOrder[i] === this.state.grid[this.state.startPosition[0]][this.state.startPosition[1]]) continue;\n\n         let tID = setTimeout(() => {\n            const current = vistedTilesInOrder[i];\n            document.getElementById(`tile-${current.row}-${current.col}`).className = 'tile visited-tile';\n         }, visit_time * i);\n         let tIDList = this.state.timeoutIDs;\n         tIDList.push(tID);\n         this.setState({timeoutIDs: tIDList});\n      }\n   }\n\n   animateShortestPath(shortestPath) {\n      // Case where the path from start to finish is impossible\n      if (shortestPath.length === 0) {\n         document.getElementById('mainGrid').style.backgroundColor = 'red';\n      }\n      else {\n         for (let i = 1; i < shortestPath.length - 1; i++) {\n            const current = shortestPath[i];\n            document.getElementById(`tile-${current.row}-${current.col}`).className = 'tile shortestpath-tile';\n         }\n      }\n   }\n\n   // Deletes visitations and shortest path tiles\n   resetVisualization() {\n      if (!this.state.isSimulating) return;\n      document.getElementById('mainGrid').style.backgroundColor = '';\n      for (let i = 0; i < this.state.timeoutIDs.length; i++) {\n         clearTimeout(this.state.timeoutIDs[i]);\n      }\n      const newGrid = this.state.grid;\n      for (let i = 0; i < ROW_LENGTH; i++) {\n         for (let j = 0; j < COL_LENGTH; j++) {\n            newGrid[i][j].distance = Infinity;\n            if (newGrid[i][j].isFinish || newGrid[i][j].isStart || newGrid[i][j].isObstacle) {\n               continue;\n            }\n            if (newGrid[i][j].isVisited) {\n               newGrid[i][j].isVisited = false;\n               document.getElementById(`tile-${i}-${j}`).className = 'tile ';\n            }\n         }\n      }\n      this.setState({grid: newGrid, isSimulating: false});\n      console.log(newGrid);\n   }\n\n   visualize() {\n   // Only runs when grid is not already being simulated\n   // computes a path and dedicates time values to visited tiles\n      if (this.state.isSimulating) return;\n      this.setState({isSimulating: true});\n      const {grid, directionsIndex, algorithmIndex, startPosition, finishPosition} = this.state;\n      console.log(grid);\n      const startTile = grid[startPosition[0]][startPosition[1]];\n      const finishTile = grid[finishPosition[0]][finishPosition[1]];\n      const paths = ALGORITHMS[algorithmIndex](grid, startTile, finishTile, DIRECTIONS[directionsIndex]);\n      this.animateTraversal(paths[0]);\n      console.log(paths[1]);\n      let tID = setTimeout(() => {\n         this.animateShortestPath(paths[1]);\n      }, visit_time * paths[0].length);\n      let tIDList = this.state.timeoutIDs;\n      tIDList.push(tID);\n      this.setState({timeoutIDs: tIDList});\n      console.log(grid);\n   }\n\n    render() {\n      // main html body and method association\n      const {grid} = this.state;\n\n      return (\n         <div>\n            <div className=\"heading\">\n               <h1>General Path Finder Simulation</h1>\n               <button className=\"btn\" onClick={() => this.visualize()}>\n                  Visualize Algorithm\n               </button>\n               <button className=\"btn\" onClick={() => this.resetVisualization()}>\n                  Stop The Simulation!\n               </button>\n               <button id=\"reset\" className=\"btn\" onClick={() => this.resetGrid()}>\n                  Reset The Grid\n               </button>\n               <br /><br />\n               <span key=\"selectAlgorithm\" className=\"selection-block\">\n                  <label htmlFor=\"algorithms\" className=\"subtitle\">Choose a Algorithm to search tiles:</label>\n                  <br />\n                  <select name=\"algorithms\" className=\"selection\" id=\"algorithmSelection\">\n                     <option value=\"0\">Breadth First Search</option>\n                     <option value=\"1\">Depth First Search</option>\n                     <option value=\"2\">Dijkstra's Algorithm</option>\n                  </select>\n               </span>\n               <span key=\"selectDirection\" className=\"selection-block\">\n                  <label htmlFor=\"directions\" className=\"subtitle\">Choose a direction to travel:</label>\n                  <br />\n                  <select name=\"directions\" className=\"selection\" id=\"directionSelection\">\n                     <option value=\"0\">Cardinal</option>\n                     <option value=\"1\">Diagonal</option>\n                     <option value=\"2\">Cardinal + Diagonal</option>\n                     <option value=\"3\">Knight Traversal</option>\n                  </select>\n               </span>\n               <div class=\"slider\">\n                  Time Scale: <span id=\"time value\">25</span> ms per tile visit<br/>\n                  <input id=\"time slider\" type=\"range\" min=\"1\" max=\"50\" defaultValue=\"25\" step=\"1\" onInput={this.handleTimeScaleChange}/>\n               </div>\n               <div className=\"legend\">\n                  <span id=\"startTileLegend\" className=\"legendEntry\">\n                     <span className=\"tile start-tile\"></span>\n                     <span className=\"legendText\"> Start Tile</span>\n                  </span>\n                  <span id=\"finishTileLegend\" className=\"legendEntry\">\n                     <span className=\"tile finish-tile\"></span>\n                     <span className=\"legendText\"> Finish Tile</span>\n                  </span>\n                  <span id=\"obstacleTileLegend\" className=\"legendEntry\">\n                  <span className=\"tile obstacle-tile\"></span>\n                     <span className=\"legendText\"> Obstacle Tile</span>\n                  </span>\n                  <span id=\"unvisitedTileLegend\" className=\"legendEntry\">\n                     <span className=\"tile\"></span>\n                     <span className=\"legendText\"> Unvisited Tile</span>\n                  </span>\n                  <span id=\"visitedTileLegend\" className=\"legendEntry\">\n                  <span className=\"tile visited-tile\"></span>\n                     <span className=\"legendText\"> Visited Tile</span>\n                  </span>\n                  <span id=\"pathTileLegend\" className=\"legendEntry\">\n                     <span className=\"tile shortestpath-tile\"></span>\n                     <span className=\"legendText\"> Path Tile</span>\n                  </span>\n               </div>\n            </div>\n            <h3 id=\"adviceText\">\"{this.state.adviceObject.advice}\" - </h3>\n            <h3>{this.state.adviceObject.source}</h3>\n            <div className=\"grid\" id=\"mainGrid\" style={{width: `${COL_LENGTH*TILE_WIDTH+TILE_WIDTH/2}px`}}>\n               {grid.map((row, rowIndex) => {\n                  return (\n                  <div key={rowIndex} style={{height: `${ROW_HEIGHT}`}}>\n                     {row.map((tile, tileIndex) => {\n                        const {isStart, isFinish, isObstacle} = tile;\n                        return (\n                           <Tile\n                              key={tileIndex}\n                              onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                              onMouseUp={(row, col) => this.handleMouseUp()}\n                              onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                              row={rowIndex}\n                              col={tileIndex}\n                              isStart={isStart}\n                              isFinish={isFinish}\n                              isObstacle={isObstacle}\n                              ></Tile>\n                        );\n                     })}\n                  </div>\n                  );\n               })}\n            </div>\n         </div>\n      );\n   }\n}\n","/*\nvar stack = [];\nstack.push(2);       // stack is now [2]\nstack.push(5);       // stack is now [2, 5]\nvar i = stack.pop(); // stack is now [2]\nalert(i);            // displays 5\n\nvar queue = [];\nqueue.push(2);         // queue is now [2]\nqueue.push(5);         // queue is now [2, 5]\nvar i = queue.shift(); // queue is now [5]\nalert(i);\n*/\n\nexport function breadthFirstSearch(grid, startTile, finishTile, directions) {\n   // Prevent terminal edge cases\n   if (!startTile || !finishTile || startTile === finishTile) {\n      return false;\n   }\n   // Potentially initialize all nodes to infinite distance\n   grid[startTile.row][startTile.col].distance = 0;\n   let queue = [startTile];\n   let visitedTilesInOrder = [];\n   let possiblePath = false;\n   queueLoop:\n   while (queue.length > 0) {\n      let current = queue.shift();\n      current.isVisited = true;\n      visitedTilesInOrder.push(current);\n      for (var d in directions) {\n         let newCoordinateX = current.col + directions[d][0];\n         let newCoordinateY = current.row + directions[d][1];\n         if (newCoordinateX >= grid[0].length || newCoordinateX < 0 || \n            newCoordinateY >= grid.length || newCoordinateY < 0) {\n            continue;\n         }\n         let neighbor = grid[newCoordinateY][newCoordinateX];\n         if (neighbor === finishTile) {\n            possiblePath = true;\n            break queueLoop;\n         }\n         if (neighbor.isObstacle) {\n            continue;\n         }\n         if (neighbor.distance === Infinity) {\n            neighbor.distance = current.distance + 1;\n            queue.push(neighbor);\n         }\n      }\n   }\n\n   //let results = returnAllDistances(grid);\n   let results = []\n   results.push(visitedTilesInOrder);\n   \n   if (possiblePath) {\n      let shortestPath = collectPath(grid, finishTile, directions);\n      results.push(shortestPath);\n   }\n   else {\n      console.log(\"yo what the\");\n      results.push([]);\n   }\n   return results;\n}\n\nfunction giveNodesInfiniteDistance(grid) {\n   for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; i < grid[0].length; j++) {\n         grid[i][j].distance = Infinity;\n      }\n   }\n}\n\nfunction collectPath(grid, finishTile, directions) {\n   let pathFromStartToFinish = [finishTile];\n   let current = finishTile;\n   while (current.distance > 0) {\n      let minNeighbor = current;\n      for (var d in directions) {\n         let newCoordinateX = current.col + directions[d][0];\n         let newCoordinateY = current.row + directions[d][1];\n         if (newCoordinateX >= grid[0].length || newCoordinateX < 0 || \n            newCoordinateY >= grid.length || newCoordinateY < 0) {\n            continue;\n         }\n         let neighbor = grid[newCoordinateY][newCoordinateX];\n         if (neighbor.isVisited && neighbor.distance < minNeighbor.distance) {\n            minNeighbor = neighbor;\n         }\n      }\n      pathFromStartToFinish.unshift(minNeighbor);\n      current = minNeighbor;\n   }\n   return pathFromStartToFinish;\n}\n\nfunction returnAllDistances(grid) {\n   let results = [];\n   for (var i = 0; i < grid.length; i++) {\n      let rowResults = [];\n      for (var j = 0; j < grid[0].length; j++) {\n         rowResults.push(grid[i][j].distance);\n      }\n      results.push(rowResults);\n   }\n   return results;\n}","/*\nvar stack = [];\nstack.push(2);       // stack is now [2]\nstack.push(5);       // stack is now [2, 5]\nvar i = stack.pop(); // stack is now [2]\nalert(i);            // displays 5\n\nvar queue = [];\nqueue.push(2);         // queue is now [2]\nqueue.push(5);         // queue is now [2, 5]\nvar i = queue.shift(); // queue is now [5]\nalert(i);\n*/\n\nexport function depthFirstSearch(grid, startTile, finishTile, directions) {\n   // Prevent terminal edge cases\n   if (!startTile || !finishTile || startTile === finishTile) {\n      return false;\n   }\n   // Potentially initialize all nodes to infinite distance\n   grid[startTile.row][startTile.col].distance = 0;\n   let stack = [startTile];\n   let visitedTilesInOrder = [];\n   let possiblePath = false;\n\n   stackLoop:\n   while (stack.length > 0) {\n      let current = stack.pop();\n      if (!current.isVisited)\n         visitedTilesInOrder.push(current);\n      current.isVisited = true;\n      for (var d in directions) {\n         let newCoordinateX = current.col + directions[d][0];\n         let newCoordinateY = current.row + directions[d][1];\n         if (newCoordinateX >= grid[0].length || newCoordinateX < 0 || \n            newCoordinateY >= grid.length || newCoordinateY < 0) {\n            continue;\n         }\n         let neighbor = grid[newCoordinateY][newCoordinateX];\n         if (neighbor === finishTile) {\n            possiblePath = true;\n            break stackLoop;\n         }\n         if (neighbor.isObstacle) {\n            continue;\n         }\n         if (!neighbor.isVisited) {\n            neighbor.distance = current.distance + 1;\n            stack.push(neighbor);\n         }\n      }\n   }\n\n   //let results = returnAllDistances(grid);\n   let results = []\n   results.push(visitedTilesInOrder);\n   \n   if (possiblePath) {\n      let shortestPath = collectPath(grid, finishTile, directions);\n      results.push(shortestPath);\n   }\n   else {\n      console.log(\"yo what the\");\n      results.push([]);\n   }\n   return results;\n}\n\nfunction giveNodesInfiniteDistance(grid) {\n   for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; i < grid[0].length; j++) {\n         grid[i][j].distance = Infinity;\n      }\n   }\n}\n\nfunction collectPath(grid, finishTile, directions) {\n   let pathFromStartToFinish = [finishTile];\n   let current = finishTile;\n   while (current.distance > 0) {\n      let minNeighbor = current;\n      for (var d in directions) {\n         let newCoordinateX = current.col + directions[d][0];\n         let newCoordinateY = current.row + directions[d][1];\n         if (newCoordinateX >= grid[0].length || newCoordinateX < 0 || \n            newCoordinateY >= grid.length || newCoordinateY < 0) {\n            continue;\n         }\n         let neighbor = grid[newCoordinateY][newCoordinateX];\n         if (neighbor.isVisited && neighbor.distance < minNeighbor.distance) {\n            minNeighbor = neighbor;\n         }\n      }\n      pathFromStartToFinish.unshift(minNeighbor);\n      current = minNeighbor;\n      current.isVisited = true;\n   }\n   return pathFromStartToFinish;\n}\n\nfunction returnAllDistances(grid) {\n   let results = [];\n   for (var i = 0; i < grid.length; i++) {\n      let rowResults = [];\n      for (var j = 0; j < grid[0].length; j++) {\n         rowResults.push(grid[i][j].distance);\n      }\n      results.push(rowResults);\n   }\n   return results;\n}","// Shortest Path First Algorithm\nexport function dijkstra(grid, startTile, finishTile, directions) {\n   // Prevent terminal edge cases\n   if (!startTile || !finishTile || startTile === finishTile) {\n      return false;\n   }\n   let vertexSet = new Set();\n   let prev = {};\n   let possiblePath = false;\n   let visitedTilesInOrder = [];\n   for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[0].length; j++) {\n         grid[i][j].distance = Infinity;\n         prev[grid[i][j]] = null;\n         vertexSet.add(grid[i][j]);\n      }\n   }\n   grid[startTile.row][startTile.col].distance = 0;\n   while (vertexSet.size > 0) {\n      const vArray = Array.from(vertexSet);\n      vArray.sort((a, b) => a.distance - b.distance);\n      \n      // get minimum distance vertex\n      const current = vArray[0];\n      if (current.distance === Infinity) {\n         break;\n      }\n\n      visitedTilesInOrder.push(current);\n      current.isVisited = true;\n      vertexSet.delete(current);\n\n      if (current === finishTile) {\n         possiblePath = true;\n         break;\n      }\n\n      for (var d in directions) {\n         let newCoordinateX = current.col + directions[d][0];\n         let newCoordinateY = current.row + directions[d][1];\n         if (newCoordinateX >= grid[0].length || newCoordinateX < 0 || \n            newCoordinateY >= grid.length || newCoordinateY < 0) {\n            continue;\n         }\n         let neighbor = grid[newCoordinateY][newCoordinateX];\n         if (neighbor.isObstacle) {\n            continue;\n         }\n         if (vertexSet.has(neighbor)) {\n            const alt = current.distance + dist(current, neighbor);\n            if (alt < neighbor.distance) {\n               neighbor.distance = alt;\n               prev[[neighbor.row, neighbor.col]] = current;\n            }\n         }\n      }\n   }\n\n   if (possiblePath) {\n      let shortestPath = [];\n      let u = finishTile;\n      while (u !== undefined) {\n         shortestPath.unshift(u);\n         u = prev[[u.row, u.col]];\n      }\n\n      console.log(shortestPath);\n\n      return [visitedTilesInOrder, shortestPath];\n   }\n   else {\n      return [visitedTilesInOrder, []];\n   }\n}\n\nfunction dist(tile, otherTile) {\n   //if (!(typeof(tile) === Tile) || !(typeof(otherTile) === Tile)) return;\n   return Math.sqrt(Math.pow((tile.col - otherTile.col), 2) + Math.pow((tile.row - otherTile.row), 2));\n}\n","import './App.css';\nimport Pathfinding from './Pathfinding/Pathfinding';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Pathfinding></Pathfinding>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}