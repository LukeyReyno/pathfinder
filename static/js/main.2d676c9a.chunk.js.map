{"version":3,"sources":["Pathfinding/Tile/Tile.jsx","Pathfinding/Pathfinding.jsx","Algorithms/BFS.js","App.js","reportWebVitals.js","index.js"],"names":["Tile","props","state","this","row","col","isFinish","isStart","isObstacle","onMouseDown","onMouseUp","onMouseEnter","extraClassName","id","className","Component","START_POS","FINISH_POS","Pathfinding","grid","mouseIsPressed","initializeGrid","setState","newGrid","vistedTilesInOrder","i","setTimeout","current","document","getElementById","length","console","log","shortestPath","paths","startTile","finishTile","directions","distance","queue","visitedTilesInOrder","possiblePath","queueLoop","shift","d","isVisited","push","newCoordinateX","newCoordinateY","neighbor","Infinity","results","pathFromStartToFinish","minNeighbor","unshift","collectPath","breadthFirstSearch","animateTraversal","animateShortestPath","onClick","visualize","map","rowIndex","style","height","tile","tileIndex","handleMouseDown","handleMouseUp","handleMouseEnter","currentRow","currentTile","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2d676c9a.chunk.js","sourcesContent":["import React, {Component} from 'react';\nimport './Tile.css'\n\nexport default class Tile extends Component {\n   constructor(props) {\n      super(props);\n      this.state = {};\n   }\n\n   render() {\n      // Determine if properties are true, in order to add it to class name\n      const {\n         row, \n         col, \n         isFinish, \n         isStart,\n         isObstacle,\n         onMouseDown,\n         onMouseUp,\n         onMouseEnter,\n      } = this.props;\n      const extraClassName = isFinish\n         ? 'finish-tile'\n         : isStart\n         ? 'start-tile'\n         : isObstacle\n         ? 'obstacle-tile'\n         : '';\n\n      return (\n      <div \n      id={`tile-${row}-${col}`}\n      className={`tile ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseUp={() => onMouseUp()}\n      onMouseEnter={() => onMouseEnter(row, col)}>\n      </div>\n      )\n   }\n}\n","import React, {Component} from \"react\";\nimport Tile from './Tile/Tile'\nimport {breadthFirstSearch} from '../Algorithms/BFS'\n\nimport './Pathfinding.css';\n\nconst ROW_LENGTH = 15;\nconst COL_LENGTH = 50;\n\nconst START_POS = [10, 5];\nconst FINISH_POS = [6, 45];\n\n// Typically the same as the tile\nconst ROW_HEIGHT = \"25px\";\n\nconst VISIT_TIME_DELAY = 25; // in ms\n\nexport default class Pathfinding extends Component {\n   constructor(props) {\n      super(props);\n      this.state = {\n         grid: [],\n         mouseIsPressed: false,\n      };\n   }\n\n   componentDidMount() {\n      const grid = initializeGrid();\n      this.setState({grid});\n   }\n\n   handleMouseDown(row, col) {\n      const newGrid = this.state.grid;\n      newGrid[row][col].isObstacle = !newGrid[row][col].isObstacle;\n      this.setState({grid: newGrid, mouseIsPressed: true});\n   }\n\n   handleMouseEnter(row, col) {\n      if (!this.state.mouseIsPressed) return;\n      const newGrid = this.state.grid;\n      newGrid[row][col].isObstacle = !newGrid[row][col].isObstacle;\n      this.setState({grid: newGrid, mouseIsPressed: true});\n   }\n   \n   handleMouseUp() {\n      this.setState({mouseIsPressed: false});\n   }\n\n   animateTraversal(vistedTilesInOrder) {\n      const {grid} = this.state;\n      let newGrid = grid;\n      for (let i = 1; i < vistedTilesInOrder.length; i++) {\n         setTimeout(() => {\n            const current = vistedTilesInOrder[i];\n            document.getElementById(`tile-${current.row}-${current.col}`).className = 'tile visited-tile';\n         }, VISIT_TIME_DELAY * i);\n      }\n      console.log(grid);\n      console.log(newGrid);\n   }\n\n   animateShortestPath(shortestPath) {\n      for (let i = 1; i < shortestPath.length - 1; i++) {\n         const current = shortestPath[i];\n         document.getElementById(`tile-${current.row}-${current.col}`).className = 'tile shortestpath-tile';\n      }\n   }\n\n   visualize() {\n      const {grid} = this.state;\n      const startTile = grid[START_POS[0]][START_POS[1]];\n      const finishTile = grid[FINISH_POS[0]][FINISH_POS[1]];\n      const cardinalDirections=[[1, 0], [0, 1], [-1, 0], [0, -1]];\n      const paths = breadthFirstSearch(grid, startTile, finishTile, cardinalDirections);\n      this.animateTraversal(paths[0]);\n      setTimeout(() => {\n         this.animateShortestPath(paths[1]);\n      }, VISIT_TIME_DELAY * paths[0].length);\n      console.log(paths);\n   }\n\n   render() {\n      const {grid} = this.state;\n\n      return (\n         <div>\n            <h1>SUS</h1>\n            <button onClick={() => this.visualize()}>\n               Visualize Algorithm\n            </button>\n            <div className=\"grid\">\n               {grid.map((row, rowIndex) => {\n                  return (\n                  <div key={rowIndex} style={{height: `${ROW_HEIGHT}`}}>\n                     {row.map((tile, tileIndex) => {\n                        const {isStart, isFinish, isObstacle} = tile;\n                        return (\n                           <Tile\n                              key={tileIndex}\n                              onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                              onMouseUp={(row, col) => this.handleMouseUp()}\n                              onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                              row={rowIndex}\n                              col={tileIndex}\n                              isStart={isStart}\n                              isFinish={isFinish}\n                              isObstacle={isObstacle}\n                              ></Tile>\n                        );\n                     })}\n                  </div>\n                  );\n               })}\n            </div>\n         </div>\n      )\n   }\n}\n\nconst initializeGrid = () => {\n   const grid = [];\n   for (let row = 0; row < ROW_LENGTH; row++) {\n      const currentRow = [];\n      for (let col = 0; col < COL_LENGTH; col++) {\n         const currentTile = {\n            row,\n            col,\n            distance: Infinity,\n            isVisited: false,\n            isStart: row === START_POS[0] && col === START_POS[1],\n            isFinish: row === FINISH_POS[0] && col === FINISH_POS[1],\n         };\n         currentRow.push(currentTile);\n      }\n      grid.push(currentRow);\n   }\n   return grid;\n}\n","/*\nvar stack = [];\nstack.push(2);       // stack is now [2]\nstack.push(5);       // stack is now [2, 5]\nvar i = stack.pop(); // stack is now [2]\nalert(i);            // displays 5\n\nvar queue = [];\nqueue.push(2);         // queue is now [2]\nqueue.push(5);         // queue is now [2, 5]\nvar i = queue.shift(); // queue is now [5]\nalert(i);\n*/\n\nexport function breadthFirstSearch(grid, startTile, finishTile, directions) {\n   // Prevent terminal edge cases\n   if (!startTile || !finishTile || startTile === finishTile) {\n      return false;\n   }\n   // Potentially initialize all nodes to infinite distance\n   grid[startTile.row][startTile.col].distance = 0;\n   let queue = [startTile];\n   let visitedTilesInOrder = [];\n   let possiblePath = false;\n   queueLoop:\n   while (queue.length > 0) {\n      let current = queue.shift();\n      current.isVisited = true;\n      visitedTilesInOrder.push(current);\n      for (var d in directions) {\n         let newCoordinateX = current.col + directions[d][0];\n         let newCoordinateY = current.row + directions[d][1];\n         if (newCoordinateX >= grid[0].length || newCoordinateX < 0 || \n            newCoordinateY >= grid.length || newCoordinateY < 0) {\n            continue;\n         }\n         let neighbor = grid[newCoordinateY][newCoordinateX];\n         if (neighbor === finishTile) {\n            possiblePath = true;\n            break queueLoop;\n         }\n         if (neighbor.isObstacle) {\n            continue;\n         }\n         if (neighbor.distance === Infinity) {\n            neighbor.distance = current.distance + 1;\n            queue.push(neighbor);\n         }\n      }\n   }\n\n   //let results = returnAllDistances(grid);\n   let results = []\n   results.push(visitedTilesInOrder);\n   \n   if (possiblePath) {\n      let shortestPath = collectPath(grid, startTile, finishTile, directions);\n      results.push(shortestPath);\n   }\n   else {\n      results.push([]);\n   }\n   return results;\n}\n\nfunction giveNodesInfiniteDistance(grid) {\n   for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; i < grid[0].length; j++) {\n         grid[i][j].distance = Infinity;\n      }\n   }\n}\n\nfunction collectPath(grid, startTile, finishTile, directions) {\n   let pathFromStartToFinish = [finishTile];\n   let current = finishTile;\n   while (current.distance > 0) {\n      let minNeighbor = current;\n      for (var d in directions) {\n         let newCoordinateX = current.col + directions[d][0];\n         let newCoordinateY = current.row + directions[d][1];\n         if (newCoordinateX >= grid[0].length || newCoordinateX < 0 || \n            newCoordinateY >= grid.length || newCoordinateY < 0) {\n            continue;\n         }\n         let neighbor = grid[newCoordinateY][newCoordinateX];\n         if (neighbor.distance < minNeighbor.distance) {\n            minNeighbor = neighbor;\n         }\n      }\n      pathFromStartToFinish.unshift(minNeighbor);\n      current = minNeighbor;\n   }\n   return pathFromStartToFinish;\n}\n\nfunction returnAllDistances(grid) {\n   let results = [];\n   for (var i = 0; i < grid.length; i++) {\n      let rowResults = [];\n      for (var j = 0; j < grid[0].length; j++) {\n         rowResults.push(grid[i][j].distance);\n      }\n      results.push(rowResults);\n   }\n   return results;\n}","import './App.css';\nimport Pathfinding from './Pathfinding/Pathfinding';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Pathfinding></Pathfinding>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}